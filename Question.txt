-------------------------------------------------------------------------------------------------------------------
C++ Cast

(一) dynamic_cast只用于对象的指针和引用

1) dynamic_cast用于指针转换
    a) 子类指针转为父类，ok~
    b) 父类指针转为子类，两种情况：
        i) 父类指针真的指向子类对象，ok~
       ii) 反之，失败，返回nullptr！
2) dynamic_cast用于引用转换 (和指针情况类似)
3) 将nullptr指针转为任意类型指针，将任意类型指针转为void*指针

(二) static_cast更宽泛

1) 基本类型转换 (如：int => char, non-const => const对象, ...)
2) 空指针转为目标指针
3) 同样可以用于指针和引用，如果对于类中对象之间的上下转换，如果向下转化有问题，编译时候不会报错，运行时会报错。

(三) reinterpret_cast最广泛的转化，几乎同C-style转换

适用于如下情况：
1) int和指针转换
2) 无关联类指针之间转换
3) 函数指针之间的转换

(四) const_cast

用于去除转换对象的const和volatile

小结

dynamic_cast用于父类子类指针和引用转化，最安全也最昂贵；
static_cast类似带编译时检验的C style cast，编译器隐式转换是基于static_cast完成的；
reinpreter_cast和C style cast没有区别；
const_cast用于把const类型转换为非const类型。


-------------------------------------------------------------------------------------------------------------------
static成员变量和成员函数

(一) static成员函数：
1) 只能访问static成员变量, 原因在于：
    a. 静态成员函数和对象无关，因此没有this指针，而访问对象中非静态成员，需要通过this指针访问，因此不能访问
       非static成员变量。
    b. 而static成员不属于特定对象，同样属于类，因此可直接引用。
2) 不能定义为virtual，原因在于：
    a. 静态成员函数，不通过对象调用，也就是没有隐藏的this指针
    b. virtual成员函数，一定通过对象调用，有隐含的this指针

    a' 静态成员函数都是静态决议的 (编译时绑定)
    b' virtual函数基于动态决议的  (运行时绑定)

(二) static成员变量:
    可以被子类继承，只是取决于access permission，例如：public是可以共享访问的
    

-------------------------------------------------------------------------------------------------------------------
operator new 和 new operator

(一) 定义

Example:
    X *xp = new X;  
Explain:
    该部分new为new operator，将调用类X中的operator new，为该类对象分配内存，然后调用当前实例的构造函数。
    因此，new operator包括operator new和object的构造函数。
Example:
    delete xp;  
Explain:
    该部分的delete为delete operator，它将调用该实例的析构函数，然后调用类X的operator delete，释放该实例内存空间。

* 说明
1. new operator 和 delete operator 不能改变，这是基于C++标准。
2. operator new 和 malloc。
   1) operator new 和 operator delete 和C中的malloc和free对应，只负责分配和释放内存空间。
   2) 使用 operator new 和 operator delete 必须配对，不能使用 free 释放 operator new分配的空间，因为对内存使用的
      登记方式不同。
3. new operator 和 operator new的关系。
   1) 调用operator new分配内存。
   2) 调用构造函数生成对象。
   3) 返回相应指针。 



(二) Why use it ?

为了效率，缺省的operator new/delete有通用性，但是特定场合可以进一步提高性能，比如：动态分配大量但是小的对象时。




































