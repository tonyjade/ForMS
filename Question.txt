-------------------------------------------------------------------------------------------------------------------
C++ Cast

(一) dynamic_cast只用于对象的指针和引用

1) dynamic_cast用于指针转换
    a) 子类指针转为父类，ok~
    b) 父类指针转为子类，两种情况：
        i) 父类指针真的指向子类对象，ok~
       ii) 反之，失败，返回nullptr！
2) dynamic_cast用于引用转换 (和指针情况类似)
3) 将nullptr指针转为任意类型指针，将任意类型指针转为void*指针

(二) static_cast更宽泛

1) 基本类型转换 (如：int => char, non-const => const对象, ...)
2) 空指针转为目标指针
3) 同样可以用于指针和引用，如果对于类中对象之间的上下转换，如果向下转化有问题，编译时候不会报错，运行时会报错。

(三) reinterpret_cast最广泛的转化，几乎同C-style转换

适用于如下情况：
1) int和指针转换
2) 无关联类指针之间转换
3) 函数指针之间的转换

(四) const_cast

用于去除转换对象的const和volatile

小结

dynamic_cast用于父类子类指针和引用转化，最安全也最昂贵；
static_cast类似带编译时检验的C style cast，编译器隐式转换是基于static_cast完成的；
reinpreter_cast和C style cast没有区别；
const_cast用于把const类型转换为非const类型。


-------------------------------------------------------------------------------------------------------------------
static成员变量和成员函数

(一) static成员函数：
1) 只能访问static成员变量, 原因在于：
    a. 静态成员函数和对象无关，因此没有this指针，而访问对象中非静态成员，需要通过this指针访问，因此不能访问
       非static成员变量。
    b. 而static成员不属于特定对象，同样属于类，因此可直接引用。
2) 不能定义为virtual，原因在于：
    a. 静态成员函数，不通过对象调用，也就是没有隐藏的this指针
    b. virtual成员函数，一定通过对象调用，有隐含的this指针

    a' 静态成员函数都是静态决议的 (编译时绑定)
    b' virtual函数基于动态决议的  (运行时绑定)

(二) static成员变量:
    可以被子类继承，只是取决于access permission，例如：public是可以共享访问的
    

-------------------------------------------------------------------------------------------------------------------
operator new 和 new operator

(一) 定义

Example:
    X *xp = new X;  
Explain:
    该部分new为new operator，将调用类X中的operator new，为该类对象分配内存，然后调用当前实例的构造函数。
    因此，new operator包括operator new和object的构造函数。
Example:
    delete xp;  
Explain:
    该部分的delete为delete operator，它将调用该实例的析构函数，然后调用类X的operator delete，释放该实例内存空间。

* 说明
1. new operator 和 delete operator 不能改变，这是基于C++标准。
2. operator new 和 malloc。
   1) operator new 和 operator delete 和C中的malloc和free对应，只负责分配和释放内存空间。
   2) 使用 operator new 和 operator delete 必须配对，不能使用 free 释放 operator new分配的空间，因为对内存使用的
      登记方式不同。
3. new operator 和 operator new的关系。
   1) 调用operator new分配内存。
   2) 调用构造函数生成对象。
   3) 返回相应指针。 



(二) Why use it ?

为了效率，缺省的operator new/delete有通用性，但是特定场合可以进一步提高性能，比如：动态分配大量但是小的对象时。


-------------------------------------------------------------------------------------------------------------------
智能指针

(一) unique_ptr -- A memory doesn't have to be shared. (无copy constructor)

(二) shared_ptr -- A memory resource should be shared. 

(三) weak_ptr -- holds a reference to an object managed by a shared_ptr, but doesn't contribute to the reference count.
                 用于打破循环依赖，例如：parent和children的相互依赖。


** shared_ptr 和 auto_ptr 的区别  **
1. shared_ptr 共享，auto_ptr 独占。
2. shared_ptr 可拷贝和赋值，auto_ptr 不能。
3. shared_ptr 的缺点是可能造成循环引用。


Example: Implementation

template <typename T>
class SmartPtr {
public:
    SmartPtr() : rp(new T) {};
    SmartPtr(const SmartPtr<T> & sp) 



};


-------------------------------------------------------------------------------------------------------------------
STL 容器适配器

适配器 (adaptor) -- 利用已知的类型构建另外一种类型，实现不同的行为。
容器适配器 -- 让一种已存在的容器类型，采用另外一种不同的抽象类型工作方式实现。
例如：
    stack 和 queue 默认利用deque实现，priority_queue默认利用vector实现。
** priority_queue 可以理解为heap，每次pop都pop出最大的值 **



-------------------------------------------------------------------------------------------------------------------
查看文件上次被修改时间
    stat FileName
    ls -lc FileName

查看某文件被哪个进程占用
    ps -ef | grep 'FileName'


-------------------------------------------------------------------------------------------------------------------
关于kill

kill -9  pid
kill -15 pid

raymond@goertekssc-PowerEdge-R420:~$ kill -l
 1) SIGHUP	 2) SIGINT	 3) SIGQUIT	 4) SIGILL	 5) SIGTRAP
 6) SIGABRT	 7) SIGBUS	 8) SIGFPE	 9) SIGKILL	10) SIGUSR1
11) SIGSEGV	12) SIGUSR2	13) SIGPIPE	14) SIGALRM	15) SIGTERM
... 

15) SIGTERM -- 程序收到-15信号，会先释放资源再停止，如果程序正等待IO，可能不会马上响应，因此，多半会阻塞的。
9)  SIGKILL -- 基本都能立即响应。

kill 默认执行的就是 -15 .



-------------------------------------------------------------------------------------------------------------------
<<<<<<< HEAD
DataBase -- MySQL

MySqlServer <---- MySqlClient

登录：
    mysql -h localhost -u root -p (什么都不写就是默认的localhost/root/nullpwd)
    (登录就是 MySql client 连 server)

查看数据库和表：
    show databases; 
    show tables;

一个数据库包含多个表：
    表是行列结构，多张表放在一个数据库，多个数据库放在一个database server。

学号    姓名    地区    年龄    专业
----------------------------------------------
00001   马一方  山东    31      计算机
00002   陈小双  江西    29      药物分析

课号    课程      教室    老师
----------------------------------------------
0001    数据结构  301     马维旻
0002    C语言     502     吕威

使用某个数据库：
    use XXXdatabase;

认识SQL -- Structured Query Language

DML -- Data Manipulation Language Statements (增、删、改、查)
DDL -- Data Definition Language Statements   (建表、建库、建试图)
DCL -- Data Control Language Statements      (管理权限)


创建数据库：
    create database goertek;
删除数据库：
    drop database goertek;
使用goertek数据库：
    use goertek;

建立table：
    (建表的过程就是声明列的过程)

建表语句：
    create table TableName (
        列名1  列类型  列属性  默认值，
        ... 
        列名n  列类型  列属性  默认值
    );

Example:    
mysql> create table employee (
    ->     no    int,
    ->     name  varchar(20),
    ->     pay   int,
    ->     level int
    -> );
Query OK, 0 rows affected (0.01 sec)

mysql> show tables;
+-------------------+
| Tables_in_goertek |
+-------------------+
| employee          |
+-------------------+
1 row in set (0.00 sec)



=======
同步互斥

同步条件 -- pthread_cond_t

使用 -- 配合mutex使用

Example
>>>>>>> 19615b4258b0260341a79665af8948057297a0ef

    pthread_cond_t  warpBufferConsumedCv;
    pthread_mutex_t warpBufferConsumedMutex;

(TimeWarp.cpp)

 pthread_cond_t  warpBufferConsumedCv;
 pthread_mutex_t warpBufferConsumedMutex;


while (true) {
    if (!pthread_mutex_trylock(&gAppContext->modeContext->warpBufferConsumedMutex)) {
        pthread_cond_signal(&gAppContext->BufferConsumeCv);
        pthread_mutex_unlock(&gAppContext->BufferConsume);
    }
}

























































