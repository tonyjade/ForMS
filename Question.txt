-------------------------------------------------------------------------------------------------------------------
C++ Cast

(一) dynamic_cast只用于对象的指针和引用

1) dynamic_cast用于指针转换
    a) 子类指针转为父类，ok~
    b) 父类指针转为子类，两种情况：
        i) 父类指针真的指向子类对象，ok~
       ii) 反之，失败，返回nullptr！
2) dynamic_cast用于引用转换 (和指针情况类似)
3) 将nullptr指针转为任意类型指针，将任意类型指针转为void*指针

(二) static_cast更宽泛

1) 基本类型转换 (如：int => char, non-const => const对象, ...)
2) 空指针转为目标指针
3) 同样可以用于指针和引用，如果对于类中对象之间的上下转换，如果向下转化有问题，编译时候不会报错，运行时会报错。

(三) reinterpret_cast最广泛的转化，几乎同C-style转换

适用于如下情况：
1) int和指针转换
2) 无关联类指针之间转换
3) 函数指针之间的转换

(四) const_cast

用于去除转换对象的const和volatile

小结

dynamic_cast用于父类子类指针和引用转化，最安全也最昂贵；
static_cast类似带编译时检验的C style cast，编译器隐式转换是基于static_cast完成的；
reinpreter_cast和C style cast没有区别；
const_cast用于把const类型转换为非const类型。


-------------------------------------------------------------------------------------------------------------------
static成员变量和成员函数

(一) static成员函数：
1) 只能访问static成员变量, 原因在于：
    a. 静态成员函数和对象无关，因此没有this指针，而访问对象中非静态成员，需要通过this指针访问，因此不能访问
       非static成员变量。
    b. 而static成员不属于特定对象，同样属于类，因此可直接引用。
2) 不能定义为virtual，原因在于：
    a. 静态成员函数，不通过对象调用，也就是没有隐藏的this指针
    b. virtual成员函数，一定通过对象调用，有隐含的this指针

    a' 静态成员函数都是静态决议的 (编译时绑定)
    b' virtual函数基于动态决议的  (运行时绑定)

(二) static成员变量:
    可以被子类继承，只是取决于access permission，例如：public是可以共享访问的
    

-------------------------------------------------------------------------------------------------------------------



































